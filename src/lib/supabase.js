import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.REACT_APP_SUPABASE_URL
const supabaseKey = process.env.REACT_APP_SUPABASE_ANON_KEY

// --- Configuration Supabase ---
export const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  }
})

// --- Service d'authentification ---
export const authService = {
  async signIn(email, password) {
    console.log('üîê Tentative de connexion pour:', email);
    const result = await supabase.auth.signInWithPassword({ email, password });
    if (result.error) {
      console.error('‚ùå Erreur de connexion:', result.error);
    } else {
      console.log('‚úÖ Connexion r√©ussie');
    }
    return result;
  },
  async signOut() {
    console.log('üö™ D√©connexion en cours...');
    const { error } = await supabase.auth.signOut();
    localStorage.clear();
    sessionStorage.clear();
    if (error) {
      console.error('‚ùå Erreur lors de la d√©connexion:', error);
    } else {
      console.log('‚úÖ D√©connexion r√©ussie - Storage nettoy√©');
    }
    return { error };
  },
  onAuthStateChange(callback) {
    return supabase.auth.onAuthStateChange(callback);
  }
}

// --- Services de donn√©es ---

export const profileService = {
  async getProfile(userId) {
    console.log('üë§ R√©cup√©ration profil pour:', userId);
    const result = await supabase.from('profiles').select('*').eq('id', userId).single();
    if (result.error) {
      console.error('‚ùå Erreur r√©cup√©ration profil:', result.error);
    } else {
      console.log('‚úÖ Profil r√©cup√©r√©:', result.data?.full_name);
    }
    return result;
  },
  async getAllProfiles() {
    console.log('üë• R√©cup√©ration de tous les profils...');
    const result = await supabase.from('profiles').select('*').order('full_name');
    if (result.error) {
      console.error('‚ùå Erreur r√©cup√©ration profils:', result.error);
    } else {
      console.log('‚úÖ Profils r√©cup√©r√©s:', result.data?.length || 0);
    }
    return result;
  },
  async updateProfile(userId, updates) {
    console.log('‚úèÔ∏è Mise √† jour profil:', userId, updates);
    const { full_name, is_admin } = updates;
    const updateData = { full_name, is_admin };
    const result = await supabase.from('profiles').update(updateData).eq('id', userId);
    if (result.error) {
      console.error('‚ùå Erreur mise √† jour profil:', result.error);
    } else {
      console.log('‚úÖ Profil mis √† jour avec succ√®s');
    }
    return result;
  }
}

// Fonction pour nettoyer les noms de fichiers
const sanitizeFileName = (fileName) => {
  // Remplace les espaces et les caract√®res non autoris√©s par des tirets
  const cleaned = fileName.replace(/[^a-zA-Z0-9._-]/g, '-');
  console.log('üßπ Nom de fichier nettoy√©:', fileName, '->', cleaned);
  return cleaned;
};

export const storageService = {
  async uploadInterventionFile(file, interventionId, folder = 'report') {
    try {
      console.log('üì§ Upload fichier intervention:', {
        fileName: file.name,
        size: Math.round(file.size / 1024) + 'KB',
        type: file.type,
        interventionId,
        folder
      });

      const cleanFileName = sanitizeFileName(file.name);
      const fileName = `${Date.now()}_${cleanFileName}`;
      const filePath = `${interventionId}/${folder}/${fileName}`;

      console.log('üóÇÔ∏è Chemin de stockage:', filePath);

      const { error } = await supabase.storage.from('intervention-files').upload(filePath, file);

      if (error) {
        console.error('‚ùå Erreur upload vers storage:', error);
        return { publicURL: null, error };
      }

      const { data } = supabase.storage.from('intervention-files').getPublicUrl(filePath);
      const publicURL = data.publicUrl;

      console.log('‚úÖ Fichier upload√© avec succ√®s:', publicURL);
      return { publicURL, error: null };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale upload intervention:', error);
      return { publicURL: null, error };
    }
  },

  async uploadVaultFile(file, userId) {
    try {
      console.log('üì§ Upload fichier coffre-fort:', {
        fileName: file.name,
        size: Math.round(file.size / 1024) + 'KB',
        userId
      });

      const cleanFileName = sanitizeFileName(file.name);
      const fileName = `${Date.now()}_${cleanFileName}`;
      const filePath = `${userId}/${fileName}`;

      console.log('üóÇÔ∏è Chemin de stockage vault:', filePath);

      const { error } = await supabase.storage.from('vault-files').upload(filePath, file);

      if (error) {
        console.error('‚ùå Erreur upload vers vault storage:', error);
        return { publicURL: null, filePath: null, error };
      }

      const { data } = supabase.storage.from('vault-files').getPublicUrl(filePath);
      const publicURL = data.publicUrl;

      console.log('‚úÖ Fichier vault upload√© avec succ√®s:', publicURL);
      return { publicURL, filePath: filePath, error: null };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale upload vault:', error);
      return { publicURL: null, filePath: null, error };
    }
  },

  async deleteVaultFile(filePath) {
    console.log('üóëÔ∏è Suppression fichier vault:', filePath);
    const { error } = await supabase.storage.from('vault-files').remove([filePath]);
    if (error) {
      console.error('‚ùå Erreur suppression fichier vault:', error);
    } else {
      console.log('‚úÖ Fichier vault supprim√© avec succ√®s');
    }
    return { error };
  },

  async deleteInterventionFolder(interventionId) {
    console.log('üóëÔ∏è Suppression dossier intervention:', interventionId);
    const folderPath = interventionId.toString();

    const { data: files, error: listError } = await supabase.storage
      .from('intervention-files')
      .list(folderPath, { recursive: true });

    if (listError) {
      console.error("‚ùå Erreur lors du listage des fichiers √† supprimer:", listError);
      return { error: listError };
    }

    if (!files || files.length === 0) {
      console.log('‚ÑπÔ∏è Aucun fichier √† supprimer pour l\'intervention:', interventionId);
      return { error: null };
    }

    const filePaths = files.map(file => `${folderPath}/${file.name}`);
    console.log('üóëÔ∏è Suppression de', filePaths.length, 'fichier(s)');

    const { error: removeError } = await supabase.storage
      .from('intervention-files')
      .remove(filePaths);

    if (removeError) {
      console.error('‚ùå Erreur suppression fichiers intervention:', removeError);
    } else {
      console.log('‚úÖ Dossier intervention supprim√© avec succ√®s');
    }

    return { error: removeError };
  }
}

export const interventionService = {
  async getInterventions(userId = null, archived = false) {
    console.log('üìã R√©cup√©ration interventions:', { userId, archived });

    let query = supabase
      .from('interventions')
      .select('*, intervention_assignments(profiles(full_name)), intervention_briefing_documents(*)')
      .eq('is_archived', archived)
      .order('date', { ascending: true })
      .order('time', { ascending: true });

    if (userId) {
      query = query.filter('intervention_assignments.user_id', 'eq', userId);
    }

    const result = await query;

    if (result.error) {
      console.error('‚ùå Erreur r√©cup√©ration interventions:', result.error);
    } else {
      console.log('‚úÖ Interventions r√©cup√©r√©es:', result.data?.length || 0);
    }

    return result;
  },

  async createIntervention(intervention, assignedUserIds, briefingFiles) {
    try {
      console.log('‚ûï Cr√©ation nouvelle intervention:', {
        client: intervention.client,
        service: intervention.service,
        assignedUsers: assignedUserIds.length,
        briefingFiles: briefingFiles.length
      });

      // Cr√©ation de l'intervention
      const { data: interventionData, error: interventionError } = await supabase
        .from('interventions')
        .insert([{
          client: intervention.client,
          address: intervention.address,
          service: intervention.service,
          date: intervention.date,
          time: intervention.time,
        }])
        .select()
        .single();

      if (interventionError) {
        console.error('‚ùå Erreur cr√©ation intervention:', interventionError);
        return { error: interventionError };
      }

      const interventionId = interventionData.id;
      console.log('‚úÖ Intervention cr√©√©e avec ID:', interventionId);

      // Assignation des utilisateurs
      if (assignedUserIds.length > 0) {
        const assignments = assignedUserIds.map(userId => ({
          intervention_id: interventionId,
          user_id: userId
        }));

        const { error: assignmentError } = await supabase
          .from('intervention_assignments')
          .insert(assignments);

        if (assignmentError) {
          console.error('‚ùå Erreur assignation utilisateurs:', assignmentError);
          return { error: assignmentError };
        }

        console.log('‚úÖ Utilisateurs assign√©s:', assignedUserIds.length);
      }

      // Ajout des documents de pr√©paration
      if (briefingFiles.length > 0) {
        const { error: briefingError } = await this.addBriefingDocuments(interventionId, briefingFiles);
        if (briefingError) {
          console.error('‚ùå Erreur ajout documents pr√©paration:', briefingError);
          return { error: briefingError };
        }
        console.log('‚úÖ Documents de pr√©paration ajout√©s:', briefingFiles.length);
      }

      console.log('üéâ Intervention compl√®tement cr√©√©e avec succ√®s');
      return { error: null };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale cr√©ation intervention:', error);
      return { error };
    }
  },

  // ‚úÖ CORRECTION PRINCIPALE: Fonction updateIntervention am√©lior√©e
  async updateIntervention(id, updates) {
    try {
      console.log('üîÑ Mise √† jour intervention', id, 'avec:', {
        hasReport: !!updates.report,
        status: updates.status,
        isArchived: updates.is_archived
      });

      // ‚úÖ S'assurer que les objets complexes sont correctement s√©rialis√©s
      const sanitizedUpdates = { ...updates };

      // Si on met √† jour le rapport, s'assurer qu'il est correctement format√©
      if (updates.report) {
        sanitizedUpdates.report = {
          notes: updates.report.notes || '',
          files: Array.isArray(updates.report.files) ? updates.report.files : [],
          arrivalTime: updates.report.arrivalTime || null,
          departureTime: updates.report.departureTime || null,
          signature: updates.report.signature || null
        };

        console.log('üìÑ Rapport sanitis√©:', {
          notesLength: sanitizedUpdates.report.notes.length,
          filesCount: sanitizedUpdates.report.files.length,
          hasArrival: !!sanitizedUpdates.report.arrivalTime,
          hasDeparture: !!sanitizedUpdates.report.departureTime,
          hasSignature: !!sanitizedUpdates.report.signature
        });

        // Log d√©taill√© des fichiers
        if (sanitizedUpdates.report.files.length > 0) {
          console.log('üìÅ Fichiers dans le rapport:');
          sanitizedUpdates.report.files.forEach((file, index) => {
            console.log(`  ${index + 1}. ${file.name} (${file.type}) - ${file.url}`);
          });
        }
      }

      // ‚úÖ EX√âCUTION DE LA MISE √Ä JOUR
      const result = await supabase
        .from('interventions')
        .update(sanitizedUpdates)
        .eq('id', id);

      if (result.error) {
        console.error('‚ùå Erreur Supabase lors de la mise √† jour:', result.error);
        throw result.error;
      }

      console.log('‚úÖ Intervention mise √† jour avec succ√®s');
      return result;

    } catch (error) {
      console.error('‚ùå Erreur dans updateIntervention:', error);
      return { error };
    }
  },

  async deleteIntervention(id) {
    try {
      console.log('üóëÔ∏è Suppression intervention:', id);

      // Supprimer d'abord les fichiers du storage
      const { error: storageError } = await storageService.deleteInterventionFolder(id);
      if (storageError) {
        console.error(`‚ö†Ô∏è Impossible de supprimer le dossier de stockage pour l'intervention ${id}:`, storageError);
        // On continue quand m√™me la suppression en base
      }

      // Puis supprimer l'intervention de la base (les cascades supprimeront les relations)
      const result = await supabase.from('interventions').delete().eq('id', id);

      if (result.error) {
        console.error('‚ùå Erreur suppression intervention:', result.error);
      } else {
        console.log('‚úÖ Intervention supprim√©e avec succ√®s');
      }

      return result;

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale suppression intervention:', error);
      return { error };
    }
  },

  async addBriefingDocuments(interventionId, briefingFiles) {
    try {
      console.log('üìã Ajout documents de pr√©paration:', interventionId, briefingFiles.length, 'fichier(s)');

      for (const file of briefingFiles) {
        console.log('üì§ Upload document:', file.name);

        const { publicURL, error: uploadError } = await storageService.uploadInterventionFile(
          file,
          interventionId,
          'briefing'
        );

        if (uploadError) {
          console.error("‚ùå Erreur d'envoi pour le fichier", file.name, uploadError);
          return { error: uploadError };
        }

        console.log('üíæ Sauvegarde r√©f√©rence en base pour:', file.name);

        const { error: dbError } = await supabase
          .from('intervention_briefing_documents')
          .insert({
            intervention_id: interventionId,
            file_name: file.name,
            file_url: publicURL
          });

        if (dbError) {
          console.error("‚ùå Erreur d'insertion en base de donn√©es pour", file.name, dbError);
          return { error: dbError };
        }

        console.log('‚úÖ Document de pr√©paration ajout√©:', file.name);
      }

      console.log('üéâ Tous les documents de pr√©paration ont √©t√© ajout√©s avec succ√®s');
      return { error: null };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale ajout documents pr√©paration:', error);
      return { error };
    }
  }
}

export const leaveService = {
  async getLeaveRequests(userId = null) {
    console.log('üèñÔ∏è R√©cup√©ration demandes de cong√©:', { userId });

    let query = supabase
      .from('leave_requests')
      .select('*')
      .order('start_date', { ascending: false });

    if (userId) {
      query = query.eq('user_id', userId);
    }

    const result = await query;

    if (result.error) {
      console.error('‚ùå Erreur r√©cup√©ration demandes cong√©:', result.error);
    } else {
      console.log('‚úÖ Demandes de cong√© r√©cup√©r√©es:', result.data?.length || 0);
    }

    return result;
  },

  async createLeaveRequest(request) {
    console.log('üìù Cr√©ation demande de cong√©:', {
      userName: request.userName,
      startDate: request.startDate,
      endDate: request.endDate,
      reason: request.reason
    });

    const { userName, startDate, endDate, reason, userId } = request;

    const result = await supabase
      .from('leave_requests')
      .insert([{
        user_id: userId,
        user_name: userName,
        start_date: startDate,
        end_date: endDate,
        reason: reason,
        status: 'En attente'
      }]);

    if (result.error) {
      console.error('‚ùå Erreur cr√©ation demande cong√©:', result.error);
    } else {
      console.log('‚úÖ Demande de cong√© cr√©√©e avec succ√®s');
    }

    return result;
  },

  async updateRequestStatus(requestId, status, rejection_reason = null) {
    console.log('üîÑ Mise √† jour statut demande cong√©:', {
      requestId,
      status,
      rejection_reason
    });

    const result = await supabase
      .from('leave_requests')
      .update({ status, rejection_reason })
      .eq('id', requestId);

    if (result.error) {
      console.error('‚ùå Erreur mise √† jour statut cong√©:', result.error);
    } else {
      console.log('‚úÖ Statut demande cong√© mis √† jour');
    }

    return result;
  },

  async deleteLeaveRequest(requestId) {
    console.log('üóëÔ∏è Suppression demande de cong√©:', requestId);

    const result = await supabase
      .from('leave_requests')
      .delete()
      .eq('id', requestId);

    if (result.error) {
      console.error('‚ùå Erreur suppression demande cong√©:', result.error);
    } else {
      console.log('‚úÖ Demande de cong√© supprim√©e');
    }

    return result;
  }
}

export const vaultService = {
  async getVaultDocuments() {
    console.log('üóÑÔ∏è R√©cup√©ration documents coffre-fort...');

    const result = await supabase
      .from('vault_documents')
      .select('*, profiles(full_name)')
      .order('created_at', { ascending: false });

    if (result.error) {
      console.error('‚ùå Erreur r√©cup√©ration documents vault:', result.error);
    } else {
      console.log('‚úÖ Documents coffre-fort r√©cup√©r√©s:', result.data?.length || 0);
    }

    return result;
  },

  async createVaultDocument({ userId, name, url, path }) {
    console.log('üìÑ Cr√©ation document coffre-fort:', {
      userId,
      name,
      url: url?.substring(0, 50) + '...',
      path
    });

    const result = await supabase
      .from('vault_documents')
      .insert([{
        user_id: userId,
        file_name: name,
        file_url: url,
        file_path: path,
      }]);

    if (result.error) {
      console.error('‚ùå Erreur cr√©ation document vault:', result.error);
    } else {
      console.log('‚úÖ Document coffre-fort cr√©√© avec succ√®s');
    }

    return result;
  },

  async deleteVaultDocument(documentId) {
    try {
      console.log('üóëÔ∏è Suppression document coffre-fort:', documentId);

      // R√©cup√©rer d'abord le chemin du fichier
      const { data: doc, error: fetchError } = await supabase
        .from('vault_documents')
        .select('file_path')
        .eq('id', documentId)
        .single();

      if (fetchError || !doc) {
        console.error("‚ùå Document non trouv√© pour la suppression:", fetchError);
        return { error: fetchError || new Error("Document not found") };
      }

      // Supprimer le fichier du storage
      const { error: storageError } = await storageService.deleteVaultFile(doc.file_path);
      if (storageError) {
        console.error("‚ùå Impossible de supprimer le fichier du stockage:", storageError);
        return { error: storageError };
      }

      // Supprimer l'entr√©e de la base de donn√©es
      const result = await supabase
        .from('vault_documents')
        .delete()
        .eq('id', documentId);

      if (result.error) {
        console.error('‚ùå Erreur suppression document vault:', result.error);
      } else {
        console.log('‚úÖ Document coffre-fort supprim√© avec succ√®s');
      }

      return result;

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale suppression document vault:', error);
      return { error };
    }
  }
}